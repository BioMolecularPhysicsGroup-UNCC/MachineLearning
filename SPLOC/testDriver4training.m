% test driver for training functions within the SPLOC toolset
% ------------------------------------------------------------------------
% SPLOC = Supervised Projective Learning with Orthogonal Completeness
%
% This test driver checks sploc functions related to supervised learning
% associated with training.  
% 
% In addition to testing these functions, the purpose of this test driver
% is to serve as an example for how to use these sploc functions. 
%
% Toolset: I/O directory structure:
% 
% current directory --> sub-directories: input
%                                        splocLog
%                                        training
%                                        basisComparison
%                                        classification
%                                        analysis
%                 
% INPUT: (general description) 
% Many types of files can be read by a variety of sploc functions. Each
% such file must be formated according to specifications. In many cases, 
% the output files generated by some sploc functions will serve as input
% files for other sploc functions, which will usually have dependence. For
% example, under supervised training on various datastreams that are known
% to be functional or nonfunctional, a basis set of vectors is optimized
% to successfully classify an unknown datastream. At a later time, new
% data that comes in can be processed simply by reading in an input file
% that contains the relevant basis vectors for discrimination, without 
% redoing the training. Hence, the output from training becomes the input
% for classification along with more data. The read functions are designed
% to have flexibility so that no specific rules need to be followed.
% 
% verbosity: Specifies amount of intermediate processing steps to report.
%            Functions exist to output certain data, while verbosity has
%            no connection to that type of output and how it is reported.
%       ---> verbosity extracts hidden information within SPLOC functions.
%       ---> verbosity controls optional intermediate results ONLY:
% default: 0 => no output except what might get dumped into main log file.
% process: 1 => same as 0, writing key processing data in other log files.
% summary: 2 => same as 1, writing figures to files showing key relations.
% display: 3 => same as 2, with figures displayed on the screen, sometimes
%               with a pause, and/or with additional output printed to the
%               command window. Useful to understand how the code works!
%       ---> All printed figures have the same file type (fig, png, etc).
%       ---> Other log files are written in separate folders/directories.
% ------------------------------------------------------------------------
% 
% PROCESS: 
% SPLOC is comprised of many MATLAB functions that define the SPLOCtoolset
% See splocToolsetVersion() for detail comments about the SPLOC toolset.
%
% Each function that is tested here is listed in the menu.
%%                                                     start from sctratch
clc 
disp('  ');
disp(mfilename);
disp( dividerLine('apply new setup') );
iii = input('enter 1 to create new setup: ');
   if( iii == 1 )               % cleans out memory usage and starts fresh
   clear all
   close all
   iii = 1;
   else
   iii = 0;
   end
%%                                                           perform setup
if( iii == 1 )
% ------------------------------------------------- determine training set
   disp('  ');
   disp( dividerLine('select training set # (1 through 6)') );
   setNumber = input('Enter set #: ');
      if( setNumber < 1 )
      error('set # must not be less than 1: Available range 1-6');
      end
      if( setNumber > 6 )
      error('set # must not be greater than 6: Available range 1-6');
      end
      switch setNumber
       case 1
       fName1a = 'trainingSet1';
       fName1b = 'trainingSet1B';
       case 2
       fName1a = 'trainingSet2';
       fName1b = 'trainingSet2B';
       case 3
       fName1a = 'trainingSet3';
       fName1b = 'trainingSet3B';
       case 4
       fName1a = 'trainingSet4';
       fName1b = 'trainingSet4B';
       case 5
       fName1a = 'trainingSet5';
       fName1b = 'trainingSet5B';
       case 6
       fName1a = 'trainingSet6';
       fName1b = 'trainingSet6B';
       otherwise
       error('unknown option');
      end
   fName1 = fName1a;
% ----------------------------- determine covariance or correlation matrix
   disp('  ');
   disp( dividerLine('select covariance or correlation matrix') );
   disp('1. use covariance  matrix')
   disp('2. use correlation matrix')
   iMtype = input('   Enter option: ');
   switch iMtype
       case 1
       mType = 'cov';
       case 2
       mType = 'cor';
       otherwise
       error('unknown option');
   end
end
%%                                                     build function menu
test_sploc = false;
test_getBasisVecSpectrum = false;
disp('  ');
disp( dividerLine('select function to test') );
disp('1. sploc()   ')
disp('2. getBasisVecSpectrum()')
disp('  ');
nMenu = input('   Enter option: ');
   switch nMenu
       case 1
       test_sploc = true;
       case 2
       test_getBasisVecSpectrum = true;
       otherwise
       error('unknown option');
   end
prefix = ['opt',num2str(nMenu,'%02i'),mType,num2str(setNumber),'_'];
disp('  ');
disp( dividerLine(['setup = ',prefix]) );
%%                                                        initialize SPLOC
   if( iii == 1 )
   logFile = [prefix,mfilename];
   initializeSPLOC(1,'fName',logFile,'gType','png');
   mFormat = setDataMatrixFormat('xxx-yyy-zzz',2);  % by-pass screen input
% =========================================================== get traits1a
   disp('   ');
   disp( dividerLine(['constructing traits from: ',fName1a]) );
% ------------------------------------------------------------------------
   [~,~,FnameAdata1aF] = readFileNameList(fName1a,0,'sType','F');
   [~,~,FnameAdata1aN] = readFileNameList(fName1a,0,'sType','N');
   %[~,~,FnameAdata1aX] = readFileNameList(fName1a,0);          % X => FUN
% ------------------------------------------------------------------------
   refName1aF = [fName1a,'_F'];           % make this a suitable file name
   [AmatrixInfo1aF,table1aF] = readDataMatrices(refName1aF, ... 
                                                FnameAdata1aF,mFormat);
   disp('  ');
   disp(table1aF);
   disp('   ');
% -----------------------------
   refName1aN = [fName1a,'_N'];           % make this a suitable file name
   [AmatrixInfo1aN,table1aN] = readDataMatrices(refName1aN, ... 
                                                FnameAdata1aN,mFormat);
   disp('  ');
   disp(table1aN);
   disp('  ');
% ------------------------------------------------------------------------
   ns = 125;  %=> split data into 4 groups per system
   trait1aF4 = getMultivariateStats4sploc(AmatrixInfo1aF,ns,0,mType);
   trait1aN4 = getMultivariateStats4sploc(AmatrixInfo1aN,ns,0,mType);
   disp('   ');
% =========================================================== get traits1b
   disp( dividerLine(['constructing traits from: ',fName1b]) );
% ------------------------------------------------------------------------
   [~,~,FnameAdata1bF] = readFileNameList(fName1b,0,'sType','F');
   [~,~,FnameAdata1bN] = readFileNameList(fName1b,0,'sType','N');
   %[~,~,FnameAdata1bX] = readFileNameList(fName1b,0);          % X => FUN
% ------------------------------------------------------------------------
   refName1bF = [fName1b,'_F'];           % make this a suitable file name
   [AmatrixInfo1bF,table1bF] = readDataMatrices(refName1bF, ... 
                                                FnameAdata1bF,mFormat);
   disp('  ');
   disp(table1bF);
   disp('   ');
% -----------------------------
   refName1bN = [fName1b,'_N'];           % make this a suitable file name
   [AmatrixInfo1bN,table1bN] = readDataMatrices(refName1bN, ... 
                                                FnameAdata1bN,mFormat);
   disp('  ');
   disp(table1bN);
   disp('   ');
% ------------------------------------------------------------------------
   ns = 5000; %=> split data into 4 groups per system
   trait1bF4 = getMultivariateStats4sploc(AmatrixInfo1bF,ns,0,mType);
   trait1bN4 = getMultivariateStats4sploc(AmatrixInfo1bN,ns,0,mType);
   disp('   ');
   end
%%                                                            test sploc()
   if( test_sploc )
%% =============================================================== batch 1
   pName1a = [prefix,'Fa_Na'];
   disp('   ');
   disp('sploc()');
   disp( dividerLine('processing:  F=trait1aF4   N=trait1aN4') );
   splocResults1 = sploc(0,0,pName1a,trait1aF4,trait1aN4,2);   % aF and aN
                                                       % 3 => visualize
                           % write information to screen 2 
                     % write final information to screen 1
                                    % no write to screen 0
  %splocResults1 = sploc(0,0,pName1a,trait1aF4,trait1aN4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   plotCongruencySpectrum(splocResults1,3);
%% =============================================================== batch 2
   pName1b = [prefix,'Fb_Nb'];
   disp('   ');
   disp( dividerLine('processing:  F=trait1bF4   N=trait1bF4') );
   splocResults2 = sploc(0,0,pName1b,trait1bF4,trait1bN4,2);   % bF and bN
                                                       % 3 => visualize
                           % write information to screen 2 
                     % write final information to screen 1
                                    % no write to screen 0
  %splocResults2 = sploc(0,0,pName1b,trait1bF4,trait1bN4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   setPlotCongruencySpectrum(-1,1);
   plotCongruencySpectrum(splocResults1,3);
   plotCongruencySpectrum(splocResults2,3);
%% =============================================================== batch 3
   pName1ab = [prefix,'Fa_Nb'];
   disp('   ');
   disp( dividerLine('processing:  F=trait1aF4   N=trait1bN4') );
   splocResults3 = sploc(0,0,pName1ab,trait1aF4,trait1bN4,2);
                                                        % 3 => visualize
                            % write information to screen 2 
                      % write final information to screen 1
                                     % no write to screen 0 
  %splocResults3 = sploc(0,0,pName1ab,trait1aF4,trait1bN4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   plotCongruencySpectrum(splocResults1,3);
   plotCongruencySpectrum(splocResults2,3);
   plotCongruencySpectrum(splocResults3,3);
%% =============================================================== batch 4
   pName1ba = [prefix,'Fb_Na'];
   disp('   ');
   disp( dividerLine('processing:  F=trait1bF4   N=trait1aN4') );
   splocResults4 = sploc(0,0,pName1ba,trait1bF4,trait1aN4,2);
                                                        % 3 => visualize
  %splocResults4 = sploc(0,0,pName1ba,trait1bF4,trait1aN4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   plotCongruencySpectrum(splocResults1,3);
   plotCongruencySpectrum(splocResults2,3);
   plotCongruencySpectrum(splocResults3,3);
   plotCongruencySpectrum(splocResults4,3);
%% =============================================================== batch 5
   pName1a = [prefix,'Na_Fa'];
   disp('   ');
   disp( dividerLine('processing:  F=trait1aN4   N=trait1aF4') );
   splocResults5 = sploc(0,0,pName1a,trait1aN4,trait1aF4,2);
                                                       % 3 => visualize
                           % write information to screen 2 
                     % write final information to screen 1
                                    % no write to screen 0
  %splocResults5 = sploc(0,0,pName1a,trait1aN4,trait1aF4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   plotCongruencySpectrum(splocResults1,3);
   plotCongruencySpectrum(splocResults2,3);
   plotCongruencySpectrum(splocResults3,3);
   plotCongruencySpectrum(splocResults4,3);
   plotCongruencySpectrum(splocResults5,3);
%% =============================================================== batch 6
   pName1b = [prefix,'Nb_Fb'];
   disp('   ');
   disp( dividerLine('processing:  F=trait1bN4   N=trait1bF4') );
   splocResults6 = sploc(0,0,pName1b,trait1bN4,trait1bF4,2);
                                                       % 3 => visualize
                           % write information to screen 2 
                     % write final information to screen 1
                                    % no write to screen 0
  %splocResults6 = sploc(0,0,pName1b,trait1bN4,trait1bF4,1,0.7);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   close all
   plotCongruencySpectrum(splocResults1,3);
   plotCongruencySpectrum(splocResults2,3);
   plotCongruencySpectrum(splocResults3,3);
   plotCongruencySpectrum(splocResults4,3);
   plotCongruencySpectrum(splocResults5,3);
   plotCongruencySpectrum(splocResults6,3);
   end
%%                                              test getBasisVecSpectrum()
   if( test_getBasisVecSpectrum )
   close all
%% =============================================================== batch 1
   pName1b = [prefix,'Fb_Nb_U1'];
   disp('   ');
   disp('getBasisVecSpectrum()');
   disp( dividerLine('get U1 from sploc() with trait1bF4 & trait1bN4') );
   splocResults = sploc(0,0,pName1b,trait1bF4,trait1bN4,1);
   % REMARK: using verbosity = 3 allows learning process to be observed.
   %         using verbosity = 1 gives detailed history without figures.
   plotCongruencySpectrum(splocResults,3);
   U1 = splocResults.SBV;
   pName = [pName1b,'_nc1'];
   splocResultsSame = getBasisVecSpectrum(U1,pName,trait1bF4,trait1bN4);
   t1 = max( abs(splocResults.SEVd - splocResultsSame.SEVd) );
   t2 = max( abs(splocResults.CEVd - splocResultsSame.CEVd) );
   t3 = max( abs(splocResults.SEVi - splocResultsSame.SEVi) );
   t4 = max( abs(splocResults.CEVi - splocResultsSame.CEVi) );
      if( (t1 + t2 + t3 + t4) > 4.0e-9 )
      error('batch 1: error: No difference should be possible with same');
      end
   splocResultsSwap = getBasisVecSpectrum(U1,pName,trait1bN4,trait1bF4);
   t1 = max( abs(splocResults.SEVd - splocResultsSame.SEVd) ); 
   t2 = max( abs(splocResults.CEVd - splocResultsSame.CEVd) );
   t3 = max( abs(splocResults.SEVi - splocResultsSame.SEVi) ); 
   t4 = max( abs(splocResults.CEVi - splocResultsSame.CEVi) );
      if( (t1 + t2 + t3 + t4) > 4.0e-9 )
      error('batch 1: error: No difference should occur with swap');
      end
   disp('  ');
   disp('getBasisVecSpectrum()  passed the basic test');
   fprintf(2,'Done. \n');
   end
